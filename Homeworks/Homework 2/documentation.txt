Първата проверка, която правим е дали подадените на брой аргументи са 2 - първи за текущата програма(./main) и втори за програмата, която нашата виртуална машина трябва да изпълни. Ако не са толкова на брой, тогава програмата спира изпълнението си с помощта на функцията errx.
Следващата стъпка е като имаме програмата е да отворим програмата само за четене, което става с функцията open(...), с флага O_RDONLY, която връща файлов дескриптор и ако той има стойност -1 тогава, значи функцията не е успяла да отвори файла argv[1] и прекратяваме с помощта на err.
Ако всичко е наред при отварянето на файла, тогава статваме самия файл, за да можем да изкараме данни за неговия размер. Създаваме структура stat с името st и правим проверка дали можем да вземем статуса на файла с функцията fstat(), на която и подаваме файловия дескриптор и стат структурата, която сме създали. Ако се върне като резултат -1, значи не е успяла да извлече информация за файла и прекратяваме с функцията err.
Ако е успяла функцията да извлече инфо за файла, тогава правим проверка, тъй като по условие ни е дадено, че първите три байта са за магическата дума, после 4 байта за ram size и останалите трябва да бъдат по 25 байта за всяка инструкция от последователността. Взимаме размера на файла от извлечената информация от stat, което е st_size, изваждаме тези 3 байта за магическата дума, изваждаме и тези 4 от uint32_t за ram size и останалото трябва да се дели на 25 без остатък, иначе ще имаме проблем с прочитането на инструкциите и това ще доведе до проблем в програмата. Ако има остатък, тогава програмата завършва своето изпълнение със съобщение за грешка. 
След като е проверено, че размерът на файла е както трябва да е, следва да започнем да четем от самия файл. Създаваме масив от чарове (низ) с дължина 4, първите три клетки ще бъдат за всеки един от трите байта за магическата дума и последния за терминираща нула. Създаваме променлива rs от тип ssize_t, която ще има за цел да пази стойността получена от функцията read за прочитане на тези три байта. Ако rs е -1 следователно функцията не е успяла да прочете от файла и прекратяваме програмата с функцията err. За по-голяма прегледност на програмата съм отделил стойността 3 в отделна променлива MAGIC_WORD_SIZE.
На всякъде където се извиква функцията read аз правя две проверки първата дали rs е -1 и ако е, значи се е счупил read-a и втората е ако не е успяла да прочете броя на байтовете, които трябва поради някаква причина и в такива случаи прекратявам програмата със съответно err за -1, a за другия случай с errx.
Тъй като се иска да винаги тази дума да е "ORC" ние трябва да проверим дали е така с функцията strcmp и ако върне различно от 0, тогава програмата прекратява, защото виртуалната машина изпълнява файлове започващи с тази магическа дума.
Сега е време да прочетем ram_size от файла с функцията read. Ако отново програмата не успее да прочете файла тогава прекратява изпълнението си, т.е ако rs e -1.
Ако ram_size е нула, тогава няма каква памет да заделим за изпълнение на програмата, следователно тези инструкции няма да има къде да се прочетат. И ако е така тогава прекратяваме изпълнението на програмата.
След като сме подсигурили, че размера няма да е нула (отрицателен няма как да е заради uint32_t) заделяме памет с размер sizeof(int64_t)*ram_size за самата рам памет, която ще е с помощта на malloc. Ако arr e NULL пойнтър след заделянето на паметта, трябва да се е случил някакъв проблем при заделянето на паметта или паметта, която желаем да заделим е прекалено голяма. И ако е такъв се изчиства и се прекратява програмата, защото пак няма да имаме рам за изпълнението на програмата.
След като всичко дотук е подсигурено, че е наред, следва да започнем да четем последователността от инструкции. За удобство ще създадем структура с името Instructions която ще има optcode uint8_t за номер на инструкцията и масив от операнди с размер 3 за всеки един от подадените от инструкцията, като масива ще е от тип int64_t. Накрая след всичко ще използваме атрибута ((packed)) за да имаме възможно най-близко слепване на клетките в паметта от структурата, за да не стане проблем при четенето на структурата в цикъла, тоест да няма падинг.
Започваме да четем от файла байтовете за инструкциите в променлива, която е от тип структурата Instructions, като отново следим с променливата rs дали всичко е наред по време на четенето, ако не се прекратява програмата и се чисти паметта.
Ако rs (read size) не е колкото е размера на структурата, тогава значи read не е успял да прочете всичките байтове, а това ще доведе до проблем в програмата, следователно трябва да я прекратим с функцията errx.
За по-лесно четене на програмата, опциите за optcode ще бъдат сложени в switch.
При първия optcode 0х00 няма да правим нищо, както е дадено по условие.
С цел избягване на повторението на всеки номер на иструкция, когато ни е даден адрес, независимо дали е адрес tar, from, to, idx, v, res, v1, v2 се прави проверка дали е по-голям или равен на ram_size или по-малък от 0, за да не излезе извън рамките на паметта. Ако не удовлетворява условието ние прекратяваме програмата с errx, но преди това освобождаваме паметта. Използвам errx, защото проверките, които правя, са още на ниво преди да е станала някаква грешка като от рода segmentation fault, тоест нямаме някакъв тип грешка в errno. 
В инструкция с номер 0х95 правя проверката за адреса tar, и след което си изпълнявам командата.
В инструкция с номер 0х5d правя проверките за адресите дали и стойността на клетката с адрес from_ptr е по-малко от 0 или по-голямо или равно на ram_size, защото се иска да вземем стойността на клетката със стойността на клетката с адрес from_ptr. След като е подсигурено, че няма да излезем извън рамките на масива вече можем да изпълним това, което се иска от нас да прави инструкцията като arr[to] = arr[arr[from_ptr]].
Абсолютно същото както в горната точка за инструкцията с номер 0х63 само проверката, която правим, е за клетката с адрес стойността на клетката to_ptr. И arr[arr[to_ptr]] = arr[from].
За 0х91 правим проверка за idx адреса по гореописания начин и правим проверка дали стойността на клетката с адрес idx е по-малка от 0, тогава е невалиден скок. След като е проверено следва да започнем операцията. С помощта на lseek задаваме офсета да е на седми байт от началото на файла със SEEK_SET, заради магическата дума и размера на рам паметта. След като сме сложили отместването да е там вече правилно можем да направим скока с размер размера на структурата Instructions умножена по стойността на клетката с адрес idx, от текущата позиция с помощта на SEEK_CUR. Ако lseek върне стойност -1, или не е успял да извърши скока поради някаква грешка или скока е по-голям от броя на инструкциите.
При следващата инструкция 0хА5  правим проверка за адреса v, след което правим проверка дали стойността на клетката с този адрес е по-голяма от 0 и ако не, не влиза в if-a. Ако е да, тогава отново с lseek правим отместването с размер размера на структурата Instructions от текущата позиция с помощта на SEEK_CUR и ако lseek върне стойност -1, тогава или е настъпил проблем или сме на последната инструкция.
Сега започваме с инструкциите за аритметичните операции. Първата е 0xAD, която е за събиране. Правим проверките за адресите res, v1, v2 и ако всичко е наред, тогава arr[res] = arr[v1] + arr[v2]; 
За 0х33 са същите проверки за res, v1, v2 и arr[res] = arr[v1]*arr[v2];
За 0х04 правим проверките за res, v1, v2 и отделно дали стойността на клетката с адрес v2 не е 0, защото иначе ще се получи делене на 0. След направените проверки е време да изпълним операцията като arr[res] = arr[v1]/arr[v2].
За 0xB5 са същите проверки както в горната точка обаче arr[res] = arr[v1]%arr[v2].
Следващата инструкция 0хС1 е за извеждане на stdout символа на с ascii код на това, което е в дадената клетка v. Правим провекра за нея дали е по-малка от 0 или по-голяма или равна на ram_size. Тъй като стойностите в паметта на виртуалната машина са от тип int64_t трябва да ги кастнем към char и даваме стойността от полученото на променлива char a. След което с write на 1-stdout, това което е дадено като стойност на променливата а. Правя и проверката дали написаното е колкото е размера на char или казано 1 байт, и ако не е толкова, значи е възникнал проблем по време на изпълнението.
И последната инструкция, която е номер 0xBF е инструкцията за блокиране на изпълнението на програмата за дадено време с помощта на функцията sleep. Правим проверката за адреса v по описания начин, след което проверяваме стойността в клетката с този адрес дали е по-малка от 0, защото няма как да е отрицателно число. Но стойността е в милисекунди следователно ние трябва да го обърнем в секунди. Първо делим стойността на 1000 и после % 60 за секунди в минута и блокираме програмата за толкова време, колкото е получено от формулата, по която изчислихме.
Формулата е взета от https://www.geeksforgeeks.org/java-program-to-convert-milliseconds-to-minutes-and-seconds/ 
Ако бъде подадена инструкция с код различен от описаните по условие, ние директно прекратяваме програмата с помощта на функцията errx.
На всякъде, където прекратяваме изпълнението на програмата след заделяне на динамичната памет, независимо дали ще е с функцията err или errx, изчиствам заделената памет, която е за да не се получи memory leak.
На местата където съм използвал errx са места, където не е настъпила още грешка, но предстои да настъпи ако не е направена проверката. Местата където са с err, са места, където вече е настъпила грешка от изпълнението на дадена команда и errno ще се append-не към съобщението за грешка от функцията, като в errno имa записано име на грешка.
След като всичко е изпълнено и програмата вече трябва да прекрати успешно изпълнението си, освобождаваме заделената памет за ram, затваряме файла, който сме отворили в началото и приключваме с exit(0);
